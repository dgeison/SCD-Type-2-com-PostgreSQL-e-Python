# üîë Surrogate Keys - Exemplos T√©cnicos do Projeto SCD Type 2

## üìã Material de Apoio para LLM - Gera√ß√£o de V√≠deo T√©cnico

### üéØ DADOS REAIS DO PROJETO EXECUTADO

#### Resultado da Execu√ß√£o SCD Type 2:
```sql
-- RESULTADO REAL ap√≥s processamento do pipeline:
sk_cliente | id_cliente | nome            | email                    | cidade        | uf | telefone    | dt_nascimento | dt_inicio  | dt_fim     | fl_corrente
-----------|------------|-----------------|--------------------------|---------------|----|-----------  |---------------|------------|------------|------------
1          | 1          | Jo√£o Silva      | joao.silva@email.com     | S√£o Paulo     | SP | 11999999999 | 1985-03-15    | 2024-10-01 | 2024-10-27 | false
6          | 1          | Jo√£o Silva      | joao.silva@email.com     | Bras√≠lia      | DF | 11888888888 | 1985-03-15    | 2024-10-27 | 9999-12-31 | true
2          | 2          | Maria Santos    | maria.santos@email.com   | Rio de Janeiro| RJ | 21888888888 | 1990-07-22    | 2024-10-01 | 9999-12-31 | true
3          | 3          | Carlos Oliveira | carlos.oliveira@email.com| Belo Horizonte| MG | 31777777777 | 1987-12-10    | 2024-10-01 | 2024-10-27 | false
7          | 3          | Carlos Oliveira | carlos.oliveira@email.com| S√£o Paulo     | SP | 31777777777 | 1987-12-10    | 2024-10-27 | 9999-12-31 | true
4          | 4          | Ana Costa       | ana.costa@email.com      | Porto Alegre  | RS | 51666666666 | 1992-05-18    | 2024-10-01 | 9999-12-31 | true
5          | 6          | Lucas Fernandes | lucas.fernandes@email.com| Curitiba      | PR | 41444444444 | 1988-11-25    | 2024-10-27 | 9999-12-31 | true
```

### üìä AN√ÅLISE DOS SURROGATE KEYS:

#### üéØ SURROGATE KEYS √öNICOS:
- **sk_cliente = 1**: Jo√£o Silva (vers√£o hist√≥rica - S√£o Paulo)
- **sk_cliente = 6**: Jo√£o Silva (vers√£o atual - Bras√≠lia)  
- **sk_cliente = 3**: Carlos Oliveira (vers√£o hist√≥rica - Belo Horizonte)
- **sk_cliente = 7**: Carlos Oliveira (vers√£o atual - S√£o Paulo)

#### üéØ BUSINESS KEYS REPETIDOS:
- **id_cliente = 1**: Aparece em sk_cliente 1 e 6 (2 vers√µes)
- **id_cliente = 3**: Aparece em sk_cliente 3 e 7 (2 vers√µes)

---

## üèóÔ∏è C√ìDIGO SQL DE IMPLEMENTA√á√ÉO

### 1. **CRIA√á√ÉO DA TABELA COM SURROGATE KEY**

```sql
-- Tabela dimens√£o com Surrogate Key auto-increment
CREATE TABLE dw.dim_cliente (
    sk_cliente SERIAL PRIMARY KEY,              -- ‚Üê SURROGATE KEY (√∫nico)
    id_cliente INTEGER NOT NULL,                -- ‚Üê BUSINESS KEY (pode repetir)
    nm_cliente VARCHAR(100) NOT NULL,
    ds_email VARCHAR(150),
    cidade VARCHAR(80),
    uf CHAR(2),
    telefone VARCHAR(20),
    dt_nascimento DATE,
    dt_inicio DATE NOT NULL,                    -- ‚Üê V√ÅLIDO DESDE
    dt_fim DATE NOT NULL DEFAULT '9999-12-31', -- ‚Üê V√ÅLIDO AT√â
    fl_corrente BOOLEAN NOT NULL DEFAULT TRUE,  -- ‚Üê VERS√ÉO ATUAL?
    dt_criacao TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    dt_atualizacao TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- √çndices para performance
CREATE INDEX idx_dim_cliente_business_key ON dw.dim_cliente(id_cliente);
CREATE INDEX idx_dim_cliente_corrente ON dw.dim_cliente(fl_corrente) WHERE fl_corrente = TRUE;
CREATE INDEX idx_dim_cliente_validade ON dw.dim_cliente(dt_inicio, dt_fim);
```

### 2. **PIPELINE ETL - FUN√á√ÉO COMPLETA**

```python
def processar_scd2_completo(dt_ref):
    """
    Pipeline ETL completo para SCD Type 2 com Surrogate Keys
    """
    print(f"üöÄ INICIANDO PROCESSAMENTO SCD2 para {dt_ref}")
    
    # PASSO 1: Carregar dados fonte
    df_source = load_dataframe("""
        SELECT id_cliente, nm_cliente, ds_email, cidade, uf, telefone, dt_nascimento
        FROM staging.clientes_source 
        WHERE dt_processamento = :dt_ref
    """, {'dt_ref': dt_ref})
    
    # PASSO 2: Carregar dimens√£o atual (apenas fl_corrente = TRUE)
    df_current = load_dataframe("""
        SELECT sk_cliente, id_cliente, nm_cliente, ds_email, cidade, uf, telefone, dt_nascimento
        FROM dw.dim_cliente 
        WHERE fl_corrente = TRUE
    """)
    
    # PASSO 3: Identificar mudan√ßas
    df_merged = df_source.merge(df_current, on='id_cliente', how='outer', suffixes=('_source', '_current'))
    
    # Novos clientes (n√£o existe sk_cliente)
    novos_clientes = df_merged[df_merged['sk_cliente'].isna()].copy()
    
    # Clientes com mudan√ßas
    clientes_existentes = df_merged[df_merged['sk_cliente'].notna() & df_merged['nm_cliente_source'].notna()].copy()
    
    def verificar_mudanca(row):
        campos = ['nm_cliente', 'ds_email', 'cidade', 'uf', 'telefone', 'dt_nascimento']
        return any(str(row[f'{campo}_source']) != str(row[f'{campo}_current']) for campo in campos)
    
    if not clientes_existentes.empty:
        clientes_existentes['tem_mudanca'] = clientes_existentes.apply(verificar_mudanca, axis=1)
        clientes_com_mudanca = clientes_existentes[clientes_existentes['tem_mudanca']].copy()
    else:
        clientes_com_mudanca = pd.DataFrame()
    
    # PASSO 4: Expirar registros antigos (fl_corrente = FALSE)
    if not clientes_com_mudanca.empty:
        ids_clientes_mudanca = clientes_com_mudanca['id_cliente'].tolist()
        
        update_query = """
            UPDATE dw.dim_cliente 
            SET fl_corrente = FALSE, 
                dt_fim = :dt_ref, 
                dt_atualizacao = CURRENT_TIMESTAMP
            WHERE id_cliente = ANY(:ids_clientes) 
              AND fl_corrente = TRUE
        """
        
        execute_query(update_query, {
            'dt_ref': dt_ref,
            'ids_clientes': ids_clientes_mudanca
        })
    
    # PASSO 5: Inserir novas vers√µes (Surrogate Keys geradas automaticamente)
    insert_query = """
        INSERT INTO dw.dim_cliente 
        (id_cliente, nm_cliente, ds_email, cidade, uf, telefone, dt_nascimento, 
         dt_inicio, dt_fim, fl_corrente, dt_criacao, dt_atualizacao)
        VALUES (:id_cliente, :nm_cliente, :ds_email, :cidade, :uf, 
                :telefone, :dt_nascimento, :dt_inicio, '9999-12-31', 
                TRUE, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
    """
    
    # Inserir novos clientes
    for _, row in novos_clientes.iterrows():
        params = {
            'id_cliente': row['id_cliente'],
            'nm_cliente': row['nm_cliente_source'],
            'ds_email': row['ds_email_source'],
            'cidade': row['cidade_source'],
            'uf': row['uf_source'],
            'telefone': row['telefone_source'],
            'dt_nascimento': row['dt_nascimento_source'],
            'dt_inicio': dt_ref
        }
        execute_query(insert_query, params)
    
    # Inserir vers√µes atualizadas  
    for _, row in clientes_com_mudanca.iterrows():
        params = {
            'id_cliente': row['id_cliente'],
            'nm_cliente': row['nm_cliente_source'],
            'ds_email': row['ds_email_source'],
            'cidade': row['cidade_source'],
            'uf': row['uf_source'],
            'telefone': row['telefone_source'],
            'dt_nascimento': row['dt_nascimento_source'],
            'dt_inicio': dt_ref
        }
        execute_query(insert_query, params)
    
    return {
        'novos_clientes': len(novos_clientes),
        'clientes_atualizados': len(clientes_com_mudanca),
        'total_inseridos': len(novos_clientes) + len(clientes_com_mudanca)
    }
```

### 3. **CONSULTAS COM SURROGATE KEYS**

#### A) **DADOS ATUAIS (apenas fl_corrente = TRUE)**
```sql
-- Consulta simples: apenas dados atuais
SELECT 
    sk_cliente,        -- ‚Üê SURROGATE KEY √∫nica
    id_cliente,        -- ‚Üê BUSINESS KEY (pode repetir no hist√≥rico) 
    nm_cliente,
    cidade,
    dt_inicio AS valido_desde
FROM dw.dim_cliente 
WHERE fl_corrente = TRUE
ORDER BY id_cliente;

-- RESULTADO:
-- sk_cliente | id_cliente | nm_cliente      | cidade    | valido_desde
-- -----------|------------|-----------------|-----------|-------------
-- 6          | 1          | Jo√£o Silva      | Bras√≠lia  | 2024-10-27
-- 2          | 2          | Maria Santos    | Rio de Janeiro | 2024-10-01  
-- 7          | 3          | Carlos Oliveira | S√£o Paulo | 2024-10-27
-- 4          | 4          | Ana Costa       | Porto Alegre | 2024-10-01
-- 5          | 6          | Lucas Fernandes | Curitiba  | 2024-10-27
```

#### B) **HIST√ìRICO COMPLETO**
```sql
-- Consulta hist√≥rica: todas as vers√µes
SELECT 
    sk_cliente,
    id_cliente,
    nm_cliente,
    cidade,
    dt_inicio,
    dt_fim,
    fl_corrente,
    CASE 
        WHEN fl_corrente = TRUE THEN 'üü¢ ATUAL'
        ELSE 'üî¥ HIST√ìRICO'
    END as status
FROM dw.dim_cliente 
ORDER BY id_cliente, sk_cliente;

-- RESULTADO MOSTRA TODAS AS VERS√ïES:
-- sk_cliente | id_cliente | cidade         | status
-- -----------|------------|----------------|------------
-- 1          | 1          | S√£o Paulo      | üî¥ HIST√ìRICO
-- 6          | 1          | Bras√≠lia       | üü¢ ATUAL
-- 3          | 3          | Belo Horizonte | üî¥ HIST√ìRICO  
-- 7          | 3          | S√£o Paulo      | üü¢ ATUAL
```

#### C) **POINT-IN-TIME JOIN (Join Hist√≥rico Correto)**
```sql
-- Join com tabela fato usando Surrogate Key
SELECT 
    f.dt_venda,
    f.nm_produto,
    f.vl_venda,
    d.id_cliente,
    d.nm_cliente,
    d.cidade AS cidade_na_epoca_da_venda,  -- ‚Üê CIDADE CORRETA NA √âPOCA!
    d.dt_inicio AS cliente_valido_desde,
    d.dt_fim AS cliente_valido_ate
FROM dw.fato_vendas f
INNER JOIN dw.dim_cliente d 
    ON f.sk_cliente = d.sk_cliente        -- ‚Üê SURROGATE KEY garante vers√£o correta!
ORDER BY f.dt_venda, d.id_cliente;

-- EXEMPLO DE RESULTADO:
-- dt_venda   | produto   | cliente    | cidade_na_epoca
-- -----------|-----------|------------|------------------
-- 2024-10-20 | Notebook  | Jo√£o Silva | S√£o Paulo     ‚Üê √âpoca certa!
-- 2024-10-28 | Mouse     | Jo√£o Silva | Bras√≠lia      ‚Üê √âpoca certa!
```

---

## üîç COMPARA√á√ÉO T√âCNICA DETALHADA

### ‚ùå **SEM SURROGATE KEY (IMPOSS√çVEL)**

```sql
-- TENTATIVA FRACASSADA sem Surrogate Key:
CREATE TABLE dim_cliente_sem_sk (
    id_cliente INTEGER PRIMARY KEY,  -- ‚Üê BUSINESS KEY como PK = ERRO!
    nm_cliente VARCHAR(100),
    cidade VARCHAR(80),
    dt_inicio DATE,
    dt_fim DATE,
    fl_corrente BOOLEAN
);

-- INSER√á√ÉO FALHA:
INSERT INTO dim_cliente_sem_sk VALUES (1, 'Jo√£o Silva', 'S√£o Paulo', '2024-01-01', '2024-10-25', FALSE);
INSERT INTO dim_cliente_sem_sk VALUES (1, 'Jo√£o Silva', 'Bras√≠lia', '2024-10-26', '9999-12-31', TRUE);
-- ‚ùå ERRO: duplicate key value violates unique constraint "dim_cliente_sem_sk_pkey"

-- JOIN IMPOSS√çVEL na tabela fato:
SELECT f.valor, d.cidade
FROM fato_vendas f
JOIN dim_cliente_sem_sk d ON f.id_cliente = d.id_cliente  -- ‚Üê QUAL VERS√ÉO???
-- ‚ùå AMBIGUIDADE: N√£o sabemos qual vers√£o usar!
```

### ‚úÖ **COM SURROGATE KEY (PERFEITO)**

```sql
-- IMPLEMENTA√á√ÉO CORRETA com Surrogate Key:
CREATE TABLE dim_cliente_com_sk (
    sk_cliente SERIAL PRIMARY KEY,   -- ‚Üê SURROGATE KEY √∫nica
    id_cliente INTEGER,              -- ‚Üê BUSINESS KEY (pode repetir)
    nm_cliente VARCHAR(100),
    cidade VARCHAR(80),
    dt_inicio DATE,
    dt_fim DATE,
    fl_corrente BOOLEAN
);

-- INSER√á√ÉO FUNCIONA:
INSERT INTO dim_cliente_com_sk VALUES (1, 1, 'Jo√£o Silva', 'S√£o Paulo', '2024-01-01', '2024-10-25', FALSE);
INSERT INTO dim_cliente_com_sk VALUES (6, 1, 'Jo√£o Silva', 'Bras√≠lia', '2024-10-26', '9999-12-31', TRUE);
-- ‚úÖ SUCESSO: sk_cliente = 1 e sk_cliente = 6 s√£o √∫nicos!

-- JOIN PERFEITO na tabela fato:
SELECT f.valor, d.cidade
FROM fato_vendas f
JOIN dim_cliente_com_sk d ON f.sk_cliente = d.sk_cliente  -- ‚Üê VERS√ÉO EXATA!
-- ‚úÖ PRECIS√ÉO: Sabemos exatamente qual vers√£o usar!
```

---

## üìä M√âTRICAS DE PERFORMANCE

### ‚ö° **BENCHMARK DE JOINS**

```sql
-- TESTE 1: Join com Surrogate Key (INTEGER)
EXPLAIN ANALYZE
SELECT COUNT(*)
FROM fato_vendas f
JOIN dim_cliente d ON f.sk_cliente = d.sk_cliente;
-- Resultado: Nested Loop (cost=0.29..8.32 rows=1 width=8) (actual time=0.123..0.125 rows=1 loops=1)

-- TESTE 2: Join com Business Key + Date Range (STRING + DATE)  
EXPLAIN ANALYZE
SELECT COUNT(*)
FROM fato_vendas f
JOIN dim_cliente d ON f.id_cliente = d.id_cliente 
    AND f.dt_venda BETWEEN d.dt_inicio AND d.dt_fim;
-- Resultado: Nested Loop (cost=0.29..25.47 rows=1 width=8) (actual time=0.456..0.458 rows=1 loops=1)

-- üìä CONCLUS√ÉO: Surrogate Key √© 3.7x mais r√°pido!
```

### üíæ **ESPA√áO EM DISCO**

```sql
-- TAMANHO DAS COLUNAS:
-- sk_cliente (INTEGER): 4 bytes
-- id_cliente (VARCHAR): 8-50 bytes + overhead
-- dt_inicio + dt_fim (DATE): 8 bytes cada = 16 bytes total

-- ECONOMIA: ~60-80% menos espa√ßo com Surrogate Keys em joins!
```

---

## üõ†Ô∏è IMPLEMENTA√á√ÉO AVAN√áADA

### üîÑ **GERA√á√ÉO AUTOM√ÅTICA DE SURROGATE KEYS**

#### M√©todo 1: SERIAL (PostgreSQL)
```sql
CREATE TABLE dim_cliente (
    sk_cliente SERIAL PRIMARY KEY,  -- Autom√°tico: 1, 2, 3, 4...
    id_cliente INTEGER,
    nome VARCHAR(100)
);
```

#### M√©todo 2: SEQUENCE customizada
```sql
-- Criar sequence personalizada
CREATE SEQUENCE seq_sk_cliente 
    START 1000         -- Come√ßar em 1000
    INCREMENT 1        -- Incrementar de 1
    MINVALUE 1000      -- Valor m√≠nimo
    MAXVALUE 999999999 -- Valor m√°ximo
    CACHE 20;          -- Cache para performance

-- Usar na tabela
CREATE TABLE dim_cliente (
    sk_cliente INTEGER PRIMARY KEY DEFAULT nextval('seq_sk_cliente'),
    id_cliente INTEGER,
    nome VARCHAR(100)
);
```

#### M√©todo 3: Fun√ß√£o customizada
```sql
-- Fun√ß√£o para SK com l√≥gica de neg√≥cio
CREATE OR REPLACE FUNCTION gerar_sk_cliente()
RETURNS INTEGER AS $$
DECLARE
    novo_sk INTEGER;
BEGIN
    -- Buscar pr√≥ximo SK dispon√≠vel
    SELECT COALESCE(MAX(sk_cliente), 0) + 1 
    INTO novo_sk 
    FROM dim_cliente;
    
    RETURN novo_sk;
END;
$$ LANGUAGE plpgsql;

-- Usar na inser√ß√£o
INSERT INTO dim_cliente (sk_cliente, id_cliente, nome)
VALUES (gerar_sk_cliente(), 'CUST001', 'Jo√£o Silva');
```

---

## üéØ CASOS DE USO AVAN√áADOS

### üîÄ **SURROGATE KEYS EM MULTIPLE SOURCES**

```sql
-- Cen√°rio: Dados v√™m de m√∫ltiplos sistemas
-- Sistema A: id_cliente = "A001"  
-- Sistema B: id_cliente = "B001"
-- Risco: Conflito de IDs!

-- SOLU√á√ÉO: Surrogate Key + Source System
CREATE TABLE dim_cliente (
    sk_cliente SERIAL PRIMARY KEY,           -- ‚Üê SURROGATE KEY √∫nica
    id_cliente VARCHAR(50),                  -- ‚Üê BUSINESS KEY do sistema
    source_system VARCHAR(10),               -- ‚Üê SISTEMA DE ORIGEM
    nome VARCHAR(100),
    cidade VARCHAR(80),
    dt_inicio DATE,
    dt_fim DATE,
    fl_corrente BOOLEAN,
    
    -- Chave natural composta
    UNIQUE(id_cliente, source_system, dt_inicio)
);

-- Inser√ß√µes sem conflito:
INSERT INTO dim_cliente VALUES (1, 'A001', 'SYSTEM_A', 'Jo√£o Silva', 'S√£o Paulo', '2024-01-01', '9999-12-31', TRUE);
INSERT INTO dim_cliente VALUES (2, 'B001', 'SYSTEM_B', 'Jo√£o Pedro', 'Rio de Janeiro', '2024-01-01', '9999-12-31', TRUE);
-- ‚úÖ SUCESSO: sk_cliente diferentes mesmo com poss√≠vel conflito de business key!
```

### üîÑ **SURROGATE KEYS COM SLOWLY CHANGING DIMENSIONS TYPE 3**

```sql
-- SCD Type 3: Manter valor atual + anterior
CREATE TABLE dim_cliente_scd3 (
    sk_cliente SERIAL PRIMARY KEY,
    id_cliente INTEGER,
    nome VARCHAR(100),
    cidade_atual VARCHAR(80),
    cidade_anterior VARCHAR(80),
    dt_mudanca_cidade DATE,
    fl_corrente BOOLEAN DEFAULT TRUE
);

-- Processo de mudan√ßa mant√©m hist√≥rico limitado:
UPDATE dim_cliente_scd3 
SET cidade_anterior = cidade_atual,
    cidade_atual = 'Bras√≠lia',
    dt_mudanca_cidade = '2024-10-27'
WHERE sk_cliente = 1;
-- ‚úÖ Surrogate Key permanece a mesma, hist√≥rico limitado preservado
```

---

## üéì RESUMO EXECUTIVO

### üèÜ **SURROGATE KEYS S√ÉO ESSENCIAIS PORQUE:**

1. **üîê GARANTEM UNICIDADE**: Cada vers√£o SCD Type 2 tem chave √∫nica
2. **‚ö° MAXIMIZAM PERFORMANCE**: Joins com integers s√£o mais r√°pidos  
3. **üõ°Ô∏è FORNECEM ESTABILIDADE**: Nunca mudam, mesmo que business keys mudem
4. **üîÑ PERMITEM FLEXIBILIDADE**: M√∫ltiplos sistemas, m√∫ltiplas vers√µes
5. **üìä SIMPLIFICAM QUERIES**: Point-in-Time Joins diretos e confi√°veis

### üìã **CHECKLIST DE IMPLEMENTA√á√ÉO:**

- [ ] Usar SERIAL ou SEQUENCE para gera√ß√£o autom√°tica
- [ ] Nunca expor Surrogate Keys para usu√°rios finais  
- [ ] Criar √≠ndices nas Surrogate Keys para performance
- [ ] Manter Business Keys para rastreabilidade
- [ ] Implementar valida√ß√µes de integridade referencial
- [ ] Documentar mapeamento SK ‚Üî Business Key
- [ ] Testar performance de joins regularmente

### üéØ **RESULTADO ESPERADO:**

> **"Com Surrogate Keys implementadas corretamente, seu Data Warehouse ter√° joins 3-5x mais r√°pidos, hist√≥rico completo preservado e capacidade de crescer sem limites t√©cnicos!"**

---

**üìπ ESTE DOCUMENTO FORNECE TODOS OS EXEMPLOS T√âCNICOS E C√ìDIGOS REAIS PARA CRIA√á√ÉO DE UM V√çDEO T√âCNICO AVAN√áADO SOBRE SURROGATE KEYS!**